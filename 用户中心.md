# 上
## 1、企业做项目流程

需求分析 => 设计（概要设计、详细设计）=> 技术选型 => 初始化 / 引入需要的技术 => 写 Demo => 写代码（实现业务逻辑） => 测试（单元测试、系统测试）=> 代码提交 / 代码评审 => 部署 => 发布上线

1. 需求分析

2. 设计（概要设计、详细设计）

3. 技术选型

4. 初始化 / 引入需要的技术

5. 写 Demo

6. 写代码（实现业务逻辑）

7. 测试（单元测试、系统测试）

8. 代码提交 / 代码评审

9. 部署

10. 发布上线

    ##  2、需求分析

    1. 登录 / 注册
    2. 用户管理（仅管理员可见）对用户的查询或者修改
    3. 用户校验（仅星球用户可见，用户编号）

##  3、技术选型

前端：

- HTML+CSS+JavaScript 三件套
- React 开发框架
- 组件库 Ant Design
- Umi 开发框架
- Umi Request 开发框架
- Ant Design Pro（现成的管理系统）

后端：

- java
- spring（依赖注入框架，帮助你管理 Java 对象，集成一些其他的内容）
- springmvc（web 框架，提供接口访问、restful接口等能力）
- mybatis（Java 操作数据库的框架，持久层框架，对 jdbc 的封装）
- mybatis-plus（对 mybatis 的增强，不用写 sql 也能实现增删改查）
- springboot（快速启动 / 快速集成项目。不用自己管理 spring 配置，不用自己整合各种框架）
- junit 单元测试库
- mysql 数据库

部署：服务器 / 容器（平台）

## 4、初始化项目
### 4.1 前端初始化

1. [https://pro.ant.design/zh-CN/docs/getting-started/](https://pro.ant.design/zh-CN/docs/getting-started/)  前端框架 

按照文档初始化

> 然后通过webstorm进入shier-usercenter-frontend文件夹，打开terminal，输入yarn，自动安装相 关依赖 安装依赖完成后，找到package.json。
> scripts下有很多脚本，找到start并运行。即可启动 ant design pro


2. umi ui 插件的构建
```
yarn add @umijs/preset-ui -D
```


3. 移除国际化 locales文件夹下的就是国际化相关文件 执行package.json的scripts下的 i18n-remove 脚
本，移除国际化，删除掉以下文件夹
locales
e2e
tests
### 4.2 后端初始化：3种初始化 Java 项目的方式

1. GitHub 搜现成的代码
2. SpringBoot 官方的模板生成器 [https://start.spring.io/](https://start.spring.io/)
3. 直接在 IDEA 开发工具中生成 （一般都是自己创建工程）
如果要引入 java 的包，可以去 maven 中心仓库寻找（[https://mvnrepository.com/](https://mvnrepository.com/)）新建好工程，然后整合 MyBatis-Plus 跟着官网来就可以了



# 中
## **1、数据库设计**
什么是数据库？存储数据 
数据库里有什么？数据表（理解为 excel 表格） 
java 操作数据库？程序代替人工

### **1.1 什么是设计数据库表？**

- 有哪些表（模型）？ 
- 表中有哪些字段？ 
- 字段的类型？ 
- 数据库字段添加索引？ 
- 表与表之间的关联？ 

举例：性别是否需要加索引？

### **1.2 用户表设计**
主要字段： 
id（主键）bigint 
username 昵称 varchar 
userAccount 登录账号 varchar 
avatarUrl 头像 varchar 
gender 性别 tinyint 
userPassword 密码 varchar 
phone 电话 varchar 
email 邮箱 varchar 
userStatus 用户状态 int 0 - 正常 
createTime 创建时间（数据插入时间）datetime 
updateTime 更新时间（数据更新时间）datetime 
isDelete 是否删除 0 1（逻辑删除）tinyint 
userRole 用户角色 0 - 普通用户 1 - 管理员

```sql
create table user
(
  id           bigint auto_increment comment 'id
  '
  primary key,
  username     varchar(256)                       null comment '用户昵称',
  userAccount  varchar(256)                       null comment '登录账号
  ',
  avatarUrl    varchar(1024)                      null comment '用户头像',
  gender       tinyint                            null comment '性别
  ',
  userPassword varchar(512)                       not null comment '密码',
  phone        varchar(128)                       null comment '电话',
  email        varchar(512)                       null comment '邮箱',
  userStatus   int      default 0                 null comment '用户状态 0 正常',
  createTime   datetime default CURRENT_TIMESTAMP null comment '创建时间',
  updateTime   datetime default CURRENT_TIMESTAMP null comment '更新时间',
  isDelete     tinyint  default 0                 null comment '是否删除',
  userRole     int      default 0                 not null comment '用户角色 0 - 普通用户 1 - 管理员',
  planetCode   varchar(512)                       null comment '星球编号'
)
    comment '用户';

alter table user add COLUMN tags varchar(1024) null comment '标签列表';
```
### 1.3**自动生成器的使用**
MyBatisX 插件，自动根据数据库生成： 

- domain：实体对象 
- mapper：操作数据库的对象 
- mapper.xml：定义了 mapper 对象和数据库的关联，可以在里面自己写 SQL 
- service：包含常用的增删改查 
- serviceImpl：具体实现 service 

从而提高开发效率！


可能出现报错，由于mybatis-plus会由下划线转换成下划线 
在配置文件当中设置这个关闭掉下划线转换
```yaml
# 自动转换为驼峰 (关闭)
mybatis-plus:
	configuration:
		map-underscore-to-camel-case: false
```

## 2、注册逻辑设计

1. 用户在前端输入账户和密码、以及校验码
2. 校验用户的账户、密码、校验密码，是否符合要求
   1. 非空
   2. 账户长度 不小于 4 位
   3. 密码 不小于 8 位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和校验密码相同
   7. 用户编号不得大于15位

3. 对密码进行加密（密码千万不要直接以明文存储到数据库中）

4. 向数据库插入用户数据

引入依赖
```xml
<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-lang3 -->
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.12.0</version>
</dependency>
```

> Apache Commons Lang3 是 Apache 软件基金会开发的一组 Java 工具类库，提供各种常用字符串 处理、数学运算、数据转换、校验等常用功能实现的工具类


> Java 中的盐值和密码混淆都是用来提高密码安全性的防护措施。
> 盐值是一种用于增加密码破解难度的 技术，在存储用户密码时，会将用户密码和一个随机生成的字符串（称为盐）进行组合，然后再进行 加密存储。
> 每个用户的盐值都是随机生成的，这样可以防止攻击者使用相同的方式对一组用户的密码 执行攻击。
> 在验证用户登录时，系统会使用相同的盐和用户输入的密码进行组合，并与存储的加密密 码进行比对，以验证密码是否正确。



用户注册功能

```java

@Resource
private UserMapper userMapper;

/**
     * 用户注册
     * @param userAccount 用户账户
     * @param userPassword 用户密码
     * @param checkPassword 校验密码
     * @return
     */
@Override
public long userRegister(String userAccount, String userPassword, String checkPassword,String planetCode) {
    // 1.非空校验
    if (StringUtils.isAnyBlank(userAccount,userPassword,checkPassword,planetCode)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"参数为空");
    }
    if (userAccount.length()<4){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户账户过短");
    }
    if (userPassword.length()<8 || checkPassword.length()<8){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户密码过短");
    }
    if (planetCode.length()>5){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"星球编号过长");
    }


    //账户不能包含特殊字符，特殊字符使用正则表达式筛选
    String validPattern="[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
    // 使用正则表达式进行校验
    Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
    if (matcher.find()) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"账户出现特殊字符");
    }

    //密码和校验密码是否相同
    if(!userPassword.equals(checkPassword)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"校验密码与密码不相同");
    }

    // 账户不能重复， 查询数据库当中是否存在相同名称用户
    QueryWrapper<User> queryWrapper=new QueryWrapper<>();
    queryWrapper.eq("userAccount",userAccount);
    long count=userMapper.selectCount(queryWrapper);
    if (count>0){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"账号重复");
    }

    // 星球标号不能重复
    queryWrapper=new QueryWrapper<>();
    queryWrapper.eq("planetCode",planetCode);
    count=userMapper.selectCount(queryWrapper);
    if (count>0){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"编号重复");
    }

    // 2.对密码进行加密
    String encryptPassword = DigestUtils.md5DigestAsHex((SALT+userPassword).getBytes());

    // 3.插入数据
    User user = new User();
    user.setUserAccount(userAccount);
    user.setUserPassword(encryptPassword);
    user.setPlanetCode(planetCode);
    boolean saveResult = this.save(user);
    if (!saveResult){
        throw new BusinessException(ErrorCode.SAVE_ERROR,"插入数据失败");
    }
    return user.getId();

}
```

# 下
写代码流程

1. 先做设计
2. 代码实现
3. 持续优化！！！（复用代码、提取公共逻辑 / 常量）

## 1、登录功能 
### 1.1 接口设计 
接受参数：用户账户、密码 
请求类型：POST 
请求体：JSON 格式的数据
> 请求参数很长时不建议用 get

返回值：用户信息（ **脱敏 **）


### 1.2 登录逻辑

1. 校验用户账户和密码是否合法
   1. 非空
   2. 账户长度不小于 4 位
   3. 密码就不小于 8 位
   4. 账户不包含特殊字符 
2. 校验密码是否输入正确，要和数据库中的密文密码（注册时加密后的）去对比
3. 用户信息脱敏，隐藏敏感信息，防止数据库中的字段泄露
4. 我们要记录用户的登录态（session），将其存到服务器上（用后端 SpringBoot 框架封装的服务器
tomcat 去记录）
cookie
5. 返回脱敏后的用户信息

> 脱敏：信息脱敏（Data Masking）是一种隐私保护技术，通过对敏感数据进行修改或者替换的方式，来保护数据的隐私和安全。
> 信息脱敏通常应用于需要处理敏感数据的场景，例如测试、开发、分 析等环境。
> 在信息脱敏技术中，被保护的敏感数据通常会被替换成某种规则定义的非敏感数据或者格式，以避免敏感数据泄露和数据窃取的风险，主要就是防止信息泄露，隐藏敏感信息


### 1.3 如何知道是哪个用户登录了？

1. 连接服务器端后，得到一个 session 状态（匿名会话），返回给前端（用户已经有了会话，但是这个会
在用户登录成功之后才会保存到Session）
2. 登录成功后，得到了登录成功的 session，并且给该session设置一些值（比如用户信息），返回给前端
一个设置 cookie 的 命令        session => cookie
3. 前端接收到后端的命令后，设置 cookie，保存到浏览器内
4. 前端再次请求后端的时候（相同的域名），在请求头中带上cookie去请求
5. 后端拿到前端传来的 cookie，找到对应的 session
6. 后端从 session 中可以取出基于该 session 存储的变量（用户的登录信息、登录名）


> 逻辑删除：逻辑删除是指在数据库中不是真正删除记录，而是标记为已删除，使得这些记录在系统中 看起来像已被删除。这比物理删除更加安全、可靠，也能够满足许多场景下的需求。

```java
/**
     * 用户登录
     * @param userAccount 用户账户
     * @param userPassword 用户密码
     * @param request
     * @return
     */
@Override
public User userLogin(String userAccount, String userPassword, HttpServletRequest request) {

    // 1.校验
    if (StringUtils.isAnyBlank(userAccount,userPassword)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"参数为空");
    }
    if (userAccount.length()<4){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户账户过短");
    }
    if (userPassword.length()<8){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户密码过短");
    }

    //账户不能包含特殊字符
    String validPattern="[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";

    Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);

    if (matcher.find()) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"账户出现特殊字符");
    }

    // 2.加密
    String encryptPassword = DigestUtils.md5DigestAsHex((SALT+userPassword).getBytes());


    //查询用户是否存在
    QueryWrapper<User> queryWrapper=new QueryWrapper<>();
    queryWrapper.eq("userAccount",userAccount);
    queryWrapper.eq("userPassword",encryptPassword);
    User user=userMapper.selectOne(queryWrapper);

    //用户不存在
    if (user==null){
        log.info("user login failed, userAccount cannot match userPassword");
        throw new BusinessException(ErrorCode.NULL_ERROR,"用户不存在");
    }

    // 3. 用户脱敏
    User safetyUser=getSafteyUser(user);

    // 4. 记录用户的登录态
    request.getSession().setAttribute(USER_LOGIN_STATE,safetyUser);
    return safetyUser;

}

/**
     * 用户脱敏
     * @param originUser
     * @return
     */
@Override
public User getSafteyUser(User originUser){
if (originUser==null){
    throw new BusinessException(ErrorCode.NULL_ERROR,"用户为空");
}

User safetyUser =new User();
safetyUser.setId(originUser.getId());
safetyUser.setUsername(originUser.getUsername());
safetyUser.setUserAccount(originUser.getUserAccount());
safetyUser.setAvatarUrl(originUser.getAvatarUrl());
safetyUser.setGender(originUser.getGender());
safetyUser.setPhone(originUser.getPhone());
safetyUser.setEmail(originUser.getEmail());
safetyUser.setPlanetCode(originUser.getPlanetCode());
safetyUser.setUserRole(originUser.getUserRole());
safetyUser.setUserStatus(originUser.getUserStatus());
safetyUser.setCreateTime(originUser.getCreateTime());
return safetyUser;

}
```

### 1.4 控制层实现 
控制层 Controller 封装请求 
application.yml 指定接口全局路径前缀：

```yaml
servlet:
	context-path: /api
```


控制器注解：
> @RestController 适用于编写 restful 风格的 api，返回值默认为 json 类型 


```java

/**
 * 用户注册请求体
 * @author 13436
 */
@Data
public class UserRegisterRequest implements Serializable {


    /**
     * 防止序列化出现冲突
     */
    public static final long serialVersionUID = 319124716373120793L;

    /**
     * 用户账号
     */
    private String userAccount;

    /**
     * 用户密码
     */
    private String userPassword;

    /**
     * 校验密码
     */
    private String checkPassword;

    /**
     * 星球编号
     */
    private String planetCode;

}

```

校验写在哪里？ 

- controller 层倾向于对请求参数本身的校验，不涉及业务逻辑本身（越少越好） 
- service 层是对业务逻辑的校验（有可能被 controller 之外的类调用）

```java
  @Resource
    private UserService userService;

    /**
     * 用户 注册
     * @param userRegisterRequest
     * @return
     */
    @PostMapping("/register")
    public BaseResponse<Long> userRegister(@RequestBody UserRegisterRequest userRegisterRequest){
        if(userRegisterRequest==null){
           throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        String userAccount = userRegisterRequest.getUserAccount();
        String userPassword = userRegisterRequest.getUserPassword();
        String checkPassword = userRegisterRequest.getCheckPassword();
        String planetCode=userRegisterRequest.getPlanetCode();
        if (StringUtils.isAnyBlank(userAccount,userPassword,checkPassword,planetCode)){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        long result=userService.userRegister(userAccount, userPassword, checkPassword,planetCode);
        return ResultUtils.success(result);
    }
```

```java
  /**
     * 用户登录
     * @param userLoginRequest
     * @param request
     * @return
     */
    @PostMapping("/login")
    public BaseResponse<User> userLogin(@RequestBody UserLoginRequest userLoginRequest, HttpServletRequest request  ){
        if(userLoginRequest==null){
            return ResultUtils.error(ErrorCode.PARAMS_ERROR);
        }
        String userAccount = userLoginRequest.getUserAccount();
        String userPassword = userLoginRequest.getUserPassword();
        if (StringUtils.isAnyBlank(userAccount,userPassword)){
            return ResultUtils.error(ErrorCode.PARAMS_ERROR);
        }
        User user=userService.userLogin(userAccount, userPassword,request);
        return ResultUtils.success(user);
    }
```


## 2、用户管理 
Session过期时间24小时

```yaml
# session登录态超时时间
session:
	timeout: 86400
```


接口设计关键：必须鉴权！！！

1. 查询用户（允许根据用户名查询）
2. 删除用户

```java
/**
     * 查询用户
     * @param searchRequest
     * @param request
     * @return
     */
@GetMapping("/search")
public BaseResponse<List<User>> searchUsers(UserSearchRequest searchRequest, HttpServletRequest request){
    if(!isAdmin(request)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR);
    }
    String username = searchRequest.getUsername();
    String userAccount = searchRequest.getUserAccount();
    String gender = searchRequest.getGender();
    String phone = searchRequest.getPhone();
    String email = searchRequest.getEmail();
    Integer userStatus = searchRequest.getUserStatus();
    String userRole = searchRequest.getUserRole();
    String userCode = searchRequest.getUserCode();


    QueryWrapper<User> queryWrapper = new QueryWrapper<>();
    Date updateTime = searchRequest.getUpdateTime();
    Date createTime = searchRequest.getCreateTime();
    // username
    if (StringUtils.isNotBlank(username)) {
        queryWrapper.like("username", username);
    }
    // userAccount
    if (StringUtils.isNotBlank(userAccount)) {
        queryWrapper.like("userAccount", userAccount);
    }
    // gender
    if (StringUtils.isNotBlank(username)) {
        queryWrapper.eq("gender", gender);
    }
    // phone
    if (StringUtils.isNotBlank(phone)) {
        queryWrapper.like("phone", phone);
    }
    // email
    if (StringUtils.isNotBlank(email)) {
        queryWrapper.like("email", email);
    }
    // userStatus
    if (userStatus != null) {
        queryWrapper.eq("userStatus", userStatus);
    }

    if (StringUtils.isNotBlank(userRole)) {
        queryWrapper.eq("userRole", userRole);
    }

    if (StringUtils.isNotBlank(userCode)) {
        queryWrapper.eq("userCode", userCode);
    }

    if (updateTime != null) {
        queryWrapper.like("updateTime", updateTime);
    }
    if (createTime != null) {
        queryWrapper.like("createTime", createTime);
    }
    List<User> userList = userService.list(queryWrapper);
    List<User> users = userList.stream().map(userService::getSafteyUser).collect(Collectors.toList());
    return ResultUtils.success(users);
}


```

```java
    /**
     * 删除用户
     * @param userDeleteRequest
     * @param request
     * @return
     */
    @PostMapping("/delete")
    public BaseResponse<Boolean> deleteUsers(@RequestBody UserDeleteRequest userDeleteRequest, HttpServletRequest request){
       if(!isAdmin(request)){
           throw new BusinessException(ErrorCode.NO_AUTH);
       }
       if (userDeleteRequest == null || userDeleteRequest.getId()<=0){
           throw new BusinessException(ErrorCode.PARAMS_ERROR);
       }
       boolean removeUser =userService.removeById(userDeleteRequest.getId());
       if (!removeUser){
           throw new BusinessException(ErrorCode.SYSTEM_ERROR,"操作数据库出错");
       }
       return ResultUtils.success(true);
    }
```

```java
 /**
     * 是否为管理员
     *
     * @param request
     * @return
     */
    private boolean isAdmin(HttpServletRequest request){
        //仅管理员可查询
        Object userObj=request.getSession().getAttribute(USER_LOGIN_STATE);
        User user = (User) userObj;
//        管理员 校验
        return user != null && user.getUserRole() == ADMIN_ROLE;
    }
```

```java

/**
 * 用户更新请求
 *
 */
@Data
public class UserSearchRequest extends PageRequest implements Serializable {

    /**
     * 用户昵称
     */
    private String username;

    /**
     * 账号
     */
    private String userAccount;


    /**
     * 性别 男 女
     */
    private String gender;


    /**
     * 电话
     */
    private String phone;

    /**
     * 邮箱
     */
    private String email;

    /**
     * 状态  0-正常 1-注销 2-封号
     */
    private Integer userStatus;


    /**
     * 更新时间
     */
    private Date updateTime;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * user-普通用户 admin-管理员 ban-封号
     */
    private String userRole;

    /**
     * 用户编号
     */
    private String userCode;

    private static final long serialVersionUID = 1L;
}
```

```java
/**
 * 用户创建请求
 *
 * @author jj
 */
@Data
public class UserDeleteRequest implements Serializable {

    private Long id;


    private static final long serialVersionUID = 1L;
}
```



## 3、前端登录注册

1. 精简界面
2. 删除不要的代码

### 3.1 前后端交互

前端需要向后端发送请求才能获取数据 / 执行操作。
怎么发请求：前端使用 ajax 来请求后端
### 3.2 前端请求库及封装关系

- axios 封装了 ajax
- request 是 ant design 项目又封装了一次

追踪 request 源码：用到了 umi 的插件、requestConfig 配置文件
###  3.3 代理

正向代理：替客户端向服务器发送请求，可以解决跨域问题
反向代理：替服务器统一接收请求。
怎么实现代理？

- Nginx 服务器
- Node.js 服务器

![Snipaste_2023-05-16_20-05-58.png](https://cdn.nlark.com/yuque/0/2023/png/29564983/1684480337695-b6cfb548-87d0-4f5d-a59e-9ca7ea033258.png#averageHue=%23fcfcfc&clientId=u59ebb550-6149-4&from=ui&id=u8b7df4dd&originHeight=882&originWidth=759&originalType=binary&ratio=1&rotation=0&showTitle=false&size=125331&status=done&style=none&taskId=u23b0aaf5-4c3b-4bcd-b4b2-d14c60b184b&title=)


# 终
## 1、前端框架介绍 
### 1.1 框架关系 
Ant Design 组件库 => 基于 React 实现 
Ant Design Procomponents => 基于 Ant Design 实现 
Ant Design Pro 后台管理系统 => 基于 Ant Design + React + Ant Design Procomponents + 其他的库实现 
MFSU：前端编译优化

## 2、注册界面 
### 2.1 Ant Design Pro（Umi 框架）权限管理 

- app.tsx：项目全局入口文件，定义了整个项目中使用的公共数据（比如用户信息） 
- access.ts 控制用户的访问权限 

获取初始状态流程：首次访问页面（刷新页面），进入 app.tsx，执行 getInitialState 方法，该方法的返回 值就是全局可用的状态值。

```tsx
const Register: React.FC = () => {
  const [type, setType] = useState<string>('account');
  //表单提交
  const handleSubmit = async (values: API.RegisterParams) => {
    const {userPassword,checkPassword }=values;
    //校验
    if (userPassword!==checkPassword){
      message.error('再次输入的密码不一致');
      return;
    }

    try {
      // 注册
      const id = await register(values);
      if (id) {
        const defaultLoginSuccessMessage = '注册成功！';
        message.success(defaultLoginSuccessMessage);
        /** 此方法会跳转到 redirect 参数所在的位置 */
        if (!history) return;
        const { query } = history.location;
        history.push({
          pathname:'/user/login',
          query,
        });
        return;
      }
    } catch (error: any) {
      const defaultLoginFailureMessage = '注册失败，请重试！';
      message.error( defaultLoginFailureMessage);
    }
  };


  return (
    <div className={styles.container}>
      <div className={styles.content}>
        <LoginForm
          submitter={{
            searchConfig:{
              submitText:'注册'
            }
          }}
          logo={<img alt="logo" src={SYSTEM_LOGO} />}
          title="编程导航知识星球"
          subTitle={<a href={PLANET_LINK} target="_blank" rel="noreferrer">比较好的编程学习圈子</a> }
          initialValues={{
            autoLogin: true,
          }}
          onFinish={async (values) => {
            await handleSubmit(values as API.RegisterParams);
          }}
          >
          <Tabs activeKey={type} onChange={setType}>
            <Tabs.TabPane key="account" tab={'账户密码注册'} />
          </Tabs>

          {type === 'account' && (
            <>
              <ProFormText
                name="userAccount"
                fieldProps={{
                  size: 'large',
                  prefix: <UserOutlined className={styles.prefixIcon} />,
                }}
                placeholder={'请输入账号'}
                rules={[
                  {
                    required: true,
                    message: '账号是必填项！',
                  },
                  {
                    min:4,
                    type:'string',
                    message:'长度不能小于4',
                  }
                ]}
                />
              <ProFormText.Password
                name="userPassword"
                fieldProps={{
                  size: 'large',
                  prefix: <LockOutlined className={styles.prefixIcon} />,
                }}
                placeholder={'请输入密码'}
                rules={[
                  {
                    required: true,
                    message: '密码是必填项！',
                  },
                  {
                    min:8,
                    type:'string',
                    message:'长度不能小于8',
                  }
                ]}
                />
              <ProFormText.Password
                name="checkPassword"
                fieldProps={{
                  size: 'large',
                  prefix: <LockOutlined className={styles.prefixIcon} />,
                  }}
                  placeholder={'请再次输入密码'}
                  rules={[
                  {
                  required: true,
                  message: '确认密码是必填项！',
                  },
                  {
                  min:8,
                  type:'string',
                  message:'长度不能小于8',
                  },
                  ]}
                  />
                  <ProFormText
                  name="planetCode"
                  fieldProps={{
                  size: 'large',
                  prefix: <UserOutlined className={styles.prefixIcon} />,
                  }}
                  placeholder={'请输入星球编号'}
                  rules={[
                  {
                  required: true,
                  message: '星球编号是必填项',
                  },
                  ]}
                  />
                  </>
                  )}
                  </LoginForm>
                  </div>
                  <Footer />
                  </div>
                  );
                  };
                  export default Register;
```

## 3、获取当前登录用户

#### controller
```java

/**
     * 获取当前登录用户
     * @param request
     * @return
     */
@GetMapping("/current")
public BaseResponse<User> getCurrentUser(HttpServletRequest request){
User safeUser=userService.getLoginUser(request);
return ResultUtils.success(safeUser);
}
```
#### service
```java
/**
     * 获取当前用户
     * @param request
     * @return
     */
User getLoginUser(HttpServletRequest request);
```

#### impl
```java
    @Override
    public User getLoginUser(HttpServletRequest request) {
        //        获取登录态
        Object userObj=request.getSession().getAttribute(USER_LOGIN_STATE);
        User currentUser= (User) userObj;
        if(currentUser==null){
            throw new BusinessException(ErrorCode.NOT_LOGIN);
        }
//        根据if获取到用户信息，去数据库查询
        Long userId = currentUser.getId();
        if (userId==null){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User user = this.getById(userId);
        if (user==null){
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        User safeUser = this.getSafteyUser(user);
        if (safeUser==null){
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }

        return  safeUser;
    }

```



## 4、用户管理界面
###  4.1 ProComponents 高级表单

1. 通过 columns 定义表格有哪些列
2. columns 属性
   1. dataIndex 对应返回数据对象的属性
   2. title 表格列名
   3. copyable 是否允许复制
   4. ellipsis 是否允许缩略
   5. valueType：用于声明这一列的类型（dateTime、select）

```tsx

export const waitTimePromise = async (time: number = 100) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(true);
    }, time);
  });
};

export const waitTime = async (time: number = 100) => {
  await waitTimePromise(time);
};



const columns: ProColumns<API.CurrentUser>[] = [
  {
    title: '序号',
    dataIndex: 'id',
    valueType: 'indexBorder',
    width: 48,
    align: 'center'
  },
  {
    title: '用户名',
    dataIndex: 'username',
    copyable: true,
    ellipsis: true,
    align: 'center'
  },
  {
    title: '用户账号',
    dataIndex: 'userAccount',
    copyable: true,
    align: 'center'
  },
  {
    title: '头像',
    dataIndex: 'avatarUrl',
    render:(_,record)=>(
      <div>
        <Image src={record.avatarUrl} width={100} />
      </div>
    ),
    copyable: true,
    align: 'center',
  },
  {
    title: '  性别 ',
    dataIndex: 'gender',
    // 枚举
    valueType: 'select',
    valueEnum: {
      0:{
        text:'男',
      },
      1:{
        text:'女',
      }
    },
    align: 'center',
  },
  {
    title: '电话',
    dataIndex: 'phone',
    copyable: true,
    align: 'center',
  },
  {
    title: '邮件',
    dataIndex: 'email',
    copyable: true,
    align: 'center',
  },
  {
    title: '   状态',
    dataIndex: 'userStatus',
    align: 'center',
  },
  {
    title: '   星球编号',
    dataIndex: 'planetCode',
    align: 'center',
  },
  {
    title: '角色',
    dataIndex: 'userRole',
    valueType: 'select',
    valueEnum: {
      0:{
        text:'普通用户',
        status:'Default'
      },
      1:{
        text:'管理员',
        status:'Success',
      }
    },
  },
  {
    title: '   创建时间',
    dataIndex: 'createTime',
    valueType:'dateTime'
  },

  {
    title: '操作',
    align: 'center',
    valueType: 'option',
    key: 'option',


    render: (text, record, _, action) => [
      <a
        key="editable"
        onClick={() => {
          action?.startEditable?.(record.id);
        }}
        >
        编辑
      </a>,
      <a href={record.url} target="_blank" rel="noopener noreferrer" key="view">
        查看
      </a>,
      <TableDropdown
        key="actionGroup"
        onSelect={() => action?.reload()}
        menus={[
          { key: 'copy', name: '复制' },
          { key: 'delete', name: '删除' },
        ]}
        />,
    ],
  },
];

export default () => {
  const actionRef = useRef<ActionType>();
  return (
    <ProTable<API.CurrentUser>
    columns={columns}
  actionRef={actionRef}
  cardBordered
  // 获取后端的数据，返回到表格
  request={async (params = {}, sort, filter) => {
    console.log(sort, filter);
    await waitTime(2000);
    const  userList=await searchUsers();
    return{
      data: userList
    }
  }}
  editable={{
    type: 'multiple',
  }}
columnsState={{
  persistenceKey: 'pro-table-singe-demos',
  persistenceType: 'localStorage',
  onChange(value){
    console.log("value:",value)
  }
}}
rowKey="id"
  search={{
  labelWidth: 'auto',
  }}
  options={{
  setting:{
  listsHeight:400,
  },
  }}
  form={{
  // 由于配置了 transform，提交的参与与定义的不同这里需要转化一下
  syncToUrl: (values, type) => {
  if (type === 'get') {
  return {
  ...values,
  created_at: [values.startTime, values.endTime],
  };
  }
  return values;
  },
  }}
  pagination={{
  pageSize: 5,
  onChange: (page) => console.log(page),
  }}
  dateFormatter="string"
  headerTitle="高级表格"></ProTable>
  );
  };

```


# 末
## 1、用户注销 
### 1.1 后端

#### controller

```java
/**
     * 用户注销
     * @param request
     * @return
     */
@PostMapping("/logout")
public BaseResponse<Integer> userLogout(HttpServletRequest request){
if(request==null){
    throw new BusinessException(ErrorCode.PARAMS_ERROR);
}
int result=userService.userLogout(request);
return ResultUtils.success(result);
}
```

#### service

```java
/**
     * 用户注销
     * @param request
     * @return
     */
int userLogout(HttpServletRequest request);
```

#### impl

```java
    /**
     * 用户注销
     * @param request
     * @return
     */
    @Override
    public int userLogout(HttpServletRequest request) {
        //移除登录态
        request.getSession().removeAttribute(USER_LOGIN_STATE);
        return 1;
    }
```


### 1.2 前端
在此文件下有注销用户接口调用

![Snipaste_2023-05-17_23-19-05.png](https://cdn.nlark.com/yuque/0/2023/png/29564983/1684481556292-375848be-e7ab-408b-8412-d8c8e8013b42.png#averageHue=%23837c56&clientId=u59ebb550-6149-4&from=ui&id=uef06a1a9&originHeight=489&originWidth=1279&originalType=binary&ratio=1&rotation=0&showTitle=false&size=84919&status=done&style=none&taskId=uae097835-c719-4a35-820c-e42aac7743c&title=)

在api.tsx中：修改成调用后端的接口
```tsx
/** 注销登录 POST /api/user/logout */
export async function outLogin(options?: { [key: string]: any }) {
  return request<Record<string, any>>('/api/user/logout', {
    method: 'POST',
    ...(options || {}),
  });
}
```


## 2、用户校验

> 仅适用于用户可信的情况

用户填写一个属于自己的编号：用户编号 userCode 
后台补充对编号的校验：长度校验、唯一性校验

### impl 校验唯一性
```java
/**
     * 用户注册
     * @param userAccount 用户账户
     * @param userPassword 用户密码
     * @param checkPassword 校验密码
     * @return
     */
@Override
public long userRegister(String userAccount, String userPassword, String checkPassword,String planetCode) {
    // 1.非空校验
    if (StringUtils.isAnyBlank(userAccount,userPassword,checkPassword,planetCode)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"参数为空");
    }
    if (userAccount.length()<4){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户账户过短");
    }
    if (userPassword.length()<8 || checkPassword.length()<8){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"用户密码过短");
    }
    if (planetCode.length()>5){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"星球编号过长");
    }


    //账户不能包含特殊字符，特殊字符使用正则表达式筛选
    String validPattern="[`~!@#$%^&*()+=|{}':;',\\\\[\\\\].<>/?~！@#￥%……&*（）——+|{}【】‘；：”“’。，、？]";
    // 使用正则表达式进行校验
    Matcher matcher = Pattern.compile(validPattern).matcher(userAccount);
    if (matcher.find()) {
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"账户出现特殊字符");
    }

    //密码和校验密码是否相同
    if(!userPassword.equals(checkPassword)){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"校验密码与密码不相同");
    }

    // 账户不能重复， 查询数据库当中是否存在相同名称用户
    QueryWrapper<User> queryWrapper=new QueryWrapper<>();
    queryWrapper.eq("userAccount",userAccount);
    long count=userMapper.selectCount(queryWrapper);
    if (count>0){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"账号重复");
    }

    // 星球标号不能重复
    queryWrapper=new QueryWrapper<>();
    queryWrapper.eq("planetCode",planetCode);
    count=userMapper.selectCount(queryWrapper);
    if (count>0){
        throw new BusinessException(ErrorCode.PARAMS_ERROR,"编号重复");
    }

    // 2.对密码进行加密
    String encryptPassword = DigestUtils.md5DigestAsHex((SALT+userPassword).getBytes());

    // 3.插入数据
    User user = new User();
    user.setUserAccount(userAccount);
    user.setUserPassword(encryptPassword);
    user.setPlanetCode(planetCode);
    boolean saveResult = this.save(user);
    if (!saveResult){
        throw new BusinessException(ErrorCode.SAVE_ERROR,"插入数据失败");
    }
    return user.getId();

}
```

## 3、后端优化 
### 3.1 通用返回对象 
目的：给对象补充一些信息，告诉前端这个请求在业务层面上是成功还是失败 
200、404、500、502、503

自定义错误码，返回类支持返回正常和错误 能够更加精准知道报错的信息

```java
/**
 * 通用返回类
 * @param <T>
 * @author  jayin
 */
@Data
public class BaseResponse<T> implements Serializable {

    private int code;

    private T data;

    private String message;

    private String description;

    public BaseResponse(int code, T data, String message,String description) {
        this.code = code;
        this.data = data;
        this.message = message;
        this.description = description;
    }

    public BaseResponse(int code, T data, String message) {
        this(code, data, message, "");
    }

    public BaseResponse(int code, T data) {
        this(code, data,"", "");
    }

    public BaseResponse(ErrorCode errorCode) {
        this(errorCode.getCode(),null,errorCode.getMessage(),errorCode.getDescription());
    }
}

```

```java
/**
 * 返回工具类
 */
public class ResultUtils {

    /**
     * 成功
     * @param data
     * @param <T>
     * @return
     */
    public static <T> BaseResponse<T> success(T data){
        return new BaseResponse<>(0,data,"ok");
    }

    /**
     * 失败
     * @param errorCode
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode){
        return new BaseResponse<>(errorCode);
    }


    /**
     * 失败
     * @param code
     * @param message
     * @param description
     * @return
     */
    public static BaseResponse error(int code,String message,String description){
        return new BaseResponse<>(code,null,message,description);
    }

    /**
     * 失败 - 消息和描述
     * @param errorCode
     * @param message
     * @param description
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode,String message,String description){
        return new BaseResponse<>(errorCode.getCode(),null,message,description);
    }

    /**
     * 失败 - 描述无消息
     * @param errorCode
     * @param description
     * @return
     */
    public static BaseResponse error(ErrorCode errorCode,String description){
        return new BaseResponse(errorCode.getCode(),errorCode.getMessage(),description);
    }

}

```

### 3.2封装全局异常处理器

实现	

1. 定义业务异常类
   1. 相对于 java 的异常类，支持更多字段
   2. 自定义构造函数，更灵活 / 快捷的设置字段
2. 编写全局异常处理器（利用 Spring AOP，在调用方法前后进行额外的处理）

作用

1. 捕获代码中所有的异常，内部消化，让前端得到更详细的业务报错 / 信息
2. 同时屏蔽掉项目框架本身的异常（不暴露服务器内部状态）
3. 集中处理，比如记录日志

```java
/**
 * @author jj
 */

public enum ErrorCode {
    SUCCESS(0,"ok",""),
    PARAMS_ERROR(40000,"请求参数错误",""),
    NULL_ERROR(40001,"请求数据为空",""),
    NOT_LOGIN(40100,"未登录",""),
    NO_AUTH(40101,"无权限",""),
    SYSTEM_ERROR(50000,"系统内部异常",""),
    SAVE_ERROR(40111,"保存失败","");

    private final int code;

    /**
     * 状态码信息
     */
    private final String message;
    /**
     * 状态码描述
     */
    private final String description;



    ErrorCode(int code, String message, String description) {
        this.code = code;
        this.message = message;
        this.description = description;
    }
    public int getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }

    public String getDescription() {
        return description;
    }

}

```

```java
/**
 * 自定义异常类
 * @author jj
 */
public class BusinessException extends RuntimeException{

    private final int code;

    private final String description;

    public int getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public BusinessException( String message,int code, String description) {
        super(message);
        this.code = code;
        this.description = description;
    }

    public BusinessException(ErrorCode errorCode) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.description = errorCode.getDescription();
    }

    public BusinessException(ErrorCode errorCode, String description) {
        super(errorCode.getMessage());
        this.code = errorCode.getCode();
        this.description = description;
    }
}

```

```java

/**
 * @author jj
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {

    /**
     * 捕获 BusinessException 异常
     * @param e 异常
     * @return
     */
    @ExceptionHandler(BusinessException.class)
    public BaseResponse businessExceptionHandler(BusinessException e){
//        日志集中处理
        log.error("businessException:"+e.getMessage(),e);
        return ResultUtils.error(e.getCode(),e.getMessage(),e.getDescription());
    }

    /**
     * 捕获 RuntimeException 异常
     * @param e 异常
     * @return
     */
    @ExceptionHandler(RuntimeException.class)
    public BaseResponse runtimeExceptionHandler(BusinessException e){
        //日志集中处理
        log.error("runtimeException:"+e);
        return ResultUtils.error(ErrorCode.SYSTEM_ERROR,e.getMessage(),"");
    }
}

```



## 4、前端优化 
**全局响应处理 **
应用场景：我们需要对接口的 **通用响应 **进行统一处理，比如从 response 中取出 data；或者根据 code 去集 中处理错误，比如用户未登录、没权限之类的。 

**优势**：不用在每个接口请求中都去写相同的逻辑 
实现：参考你用的请求封装工具的官方文档，比如 umi-request（https://github.com/umijs/umi-request#i 
nterceptor、https://blog.csdn.net/huantai3334/article/details/116780020）。如果你用 **axios**，参考 axios 的文档。 

创建新的文件，在该文件中配置一个全局请求类。在发送请求时，使用我们自己的定义的全局请求类

typing.d.ts
```java
  /**
   * 通用返回类
   */
  type BaseResponse<T>={
    code: number,
    data: T,
    message: string,
    description: string,
  }
```
将请求的参数进行封装
api.ts
```java
/** 获取当前的用户 GET /api/user/current */
export async function currentUser(options?: { [key: string]: any }) {
return request<API.BaseResponse<API.CurrentUser>>('/api/user/current', {
method: 'GET',
...(options || {}),
});
}
```
对前端的错误集中处理
```java
/**
 * request 网络请求工具
 * 更详细的 api 文档: https://github.com/umijs/umi-request
 */
import {extend} from 'umi-request';
import {message} from "antd";
import {history} from "umi";
import {stringify} from "querystring";
import * as process from "process";

/**
 * 配置request请求时的默认参数
 */
const request = extend({
  credentials: 'include', // 默认请求是否带上cookie
  prefix: process.env.NODE_ENV=== 'production' ? 'http://user-backed.code-nav.cn' : undefined
  // requestType: 'form',
});

/**
 * 所以请求拦截器
 */
request.interceptors.request.use((url, options): any => {
   console.log(`do request url= ${url}`)
  return {
    url,
    options: {
      ...options,
      headers: {

      },
    },
  };
});

/**
 * 所有响应拦截器
 */
request.interceptors.response.use(async (response, options): Promise<any> => {

  const res = await response.clone().json();
  if(res.code===0){
    return res.data;
  }
  if (res.code===40100) {
    message.error('请先登录');
    history.replace({
      pathname: '/user/login',
      search: stringify({
        redirect: location.pathname,
      }),
    });
  }else {
    message.error(res.description)
  }
  return res.data;
});

export default request;

```


# 补
## 管理员创建用户、修改用户信息、删除用户
### 管理员创建用户
```java

    /**
     * 新增用户
     * @param userAddRequest
     * @param request
     * @return
     */
    @PostMapping("/add")
    public BaseResponse<Long> addUser(@RequestBody UserAddRequest userAddRequest,HttpServletRequest request){
        if (!isAdmin(request)){
            throw new BusinessException(ErrorCode.NO_AUTH);
        }
        if (userAddRequest ==null){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User user = new User();
        BeanUtils.copyProperties(userAddRequest,user);
        boolean result = userService.save(user);
        if (!result){
            throw new BusinessException(ErrorCode.NULL_ERROR);
        }
        return ResultUtils.success(user.getId());
    }
```



### 修改用户信息
#### 修改自己
```java
 /**
     * 用户更新自己的个人信息
     * @param userUpdateMyRequest
     * @param request
     * @return
     */
    @PostMapping("/update/my")
    public BaseResponse<Boolean> updateMyUser(@RequestBody UserUpdateMyRequest userUpdateMyRequest, HttpServletRequest request){

        if (userUpdateMyRequest ==null){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = userService.getLoginUser(request);
        User user=new User();
        BeanUtils.copyProperties(userUpdateMyRequest,user);
        user.setId(loginUser.getId());
        boolean result = userService.updateById(user);
        if (!result){
            throw new BusinessException(ErrorCode.SYSTEM_ERROR,"操作数据库数值返回为false");
        }
        return ResultUtils.success(true);
    }

```


#### 修改别人
```java
    /**
     * 管理员更新用户信息
     * @param userUpdateRequest
     * @param request
     * @return
     */
    public BaseResponse<Boolean> updateUser(@RequestBody UserUpdateRequest userUpdateRequest,HttpServletRequest request){

        if (!isAdmin(request)){
            throw new BusinessException(ErrorCode.NO_AUTH);
        }
        if (userUpdateRequest == null || userUpdateRequest.getId() == null){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User user = new User();
        BeanUtils.copyProperties(userUpdateRequest,user);
        boolean result = userService.updateById(user);
        if (!result){
            throw new BusinessException(ErrorCode.SYSTEM_ERROR,"操作数据库出错");
        }
        return ResultUtils.success(true);


    }

```

#### 修改密码

```java

    /**
     * 修改密码
     *
     * @param updatePasswordRequest
     * @param request
     * @return
     */
    @PostMapping("/update/password")
    public BaseResponse<Boolean> updateUserPassword(@RequestBody UserUpdatePasswordRequest updatePasswordRequest,
                                                    HttpServletRequest request) {
        if (!isAdmin(request)) {
            throw new BusinessException(ErrorCode.NO_AUTH, "无权限");
        }
        boolean updateUserPassword = userService.updateUserPassword(updatePasswordRequest, request);
        if (updateUserPassword) {
            return ResultUtils.success(true);
        } else {
            return ResultUtils.error(ErrorCode.PARAMS_ERROR);
        }
    }
```


```java
    /**
     * 修改密码
     *
     * @param updatePasswordRequest
     * @param request
     */
    boolean updateUserPassword(UserUpdatePasswordRequest updatePasswordRequest, HttpServletRequest request);

```


```java
  @Override
    public boolean updateUserPassword(UserUpdatePasswordRequest updatePasswordRequest, HttpServletRequest request) {
        if (updatePasswordRequest == null) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        User loginUser = getLoginUser(request);
        Long userId = loginUser.getId();
        if (userId < 0 || userId == null) {
            throw new BusinessException(ErrorCode.NULL_ERROR, "不存在该用户");
        }
        User user = new User();
        BeanUtils.copyProperties(updatePasswordRequest, user);
        user.setId(loginUser.getId());

        // 使用 MD5 加密新密码
        String encryptedPassword = DigestUtils.md5DigestAsHex((SALT + updatePasswordRequest.getNewPassword()).getBytes());
        user.setUserPassword(encryptedPassword);
        if (encryptedPassword.equals(updatePasswordRequest.getUserPassword())) {
            throw new BusinessException(ErrorCode.PARAMS_ERROR, "修改密码不能相同");
        }
        boolean result = updateById(user);
        if (!result) {
            throw new BusinessException(ErrorCode.SYSTEM_ERROR,"操作数据库出错");
        }
        return true;
    }

```


### 删除用户

```java
    /**
     * 删除用户
     * @param userDeleteRequest
     * @param request
     * @return
     */
    @PostMapping("/delete")
    public BaseResponse<Boolean> deleteUsers(@RequestBody UserDeleteRequest userDeleteRequest, HttpServletRequest request){
       if(!isAdmin(request)){
           throw new BusinessException(ErrorCode.NO_AUTH);
       }
       if (userDeleteRequest == null || userDeleteRequest.getId()<=0){
           throw new BusinessException(ErrorCode.PARAMS_ERROR);
       }
       boolean removeUser =userService.removeById(userDeleteRequest.getId());
       if (!removeUser){
           throw new BusinessException(ErrorCode.SYSTEM_ERROR,"操作数据库出错");
       }
       return ResultUtils.success(true);
    }

```



## 按照更多的条件去查询用户 
```java
/**
 * 用户更新请求
 *
 * @author jj
 */
@Data
public class UserSearchRequest extends PageRequest implements Serializable {

    /**
     * 用户昵称
     */
    private String username;

    /**
     * 账号
     */
    private String userAccount;


    /**
     * 性别 男 女
     */
    private String gender;


    /**
     * 电话
     */
    private String phone;

    /**
     * 邮箱
     */
    private String email;

    /**
     * 状态  0-正常 1-注销 2-封号
     */
    private Integer userStatus;


    /**
     * 更新时间
     */
    private Date updateTime;

    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * user-普通用户 admin-管理员 ban-封号
     */
    private String userRole;

    /**
     * 用户编号
     */
    private String userCode;

    private static final long serialVersionUID = 1L;
}
```


```java
 /**
     * 查询用户
     * @param searchRequest
     * @param request
     * @return
     */
    @GetMapping("/search")
    public BaseResponse<List<User>> searchUsers(UserSearchRequest searchRequest, HttpServletRequest request){
        if(!isAdmin(request)){
            throw new BusinessException(ErrorCode.PARAMS_ERROR);
        }
        String username = searchRequest.getUsername();
        String userAccount = searchRequest.getUserAccount();
        String gender = searchRequest.getGender();
        String phone = searchRequest.getPhone();
        String email = searchRequest.getEmail();
        Integer userStatus = searchRequest.getUserStatus();
        String userRole = searchRequest.getUserRole();
        String userCode = searchRequest.getUserCode();


        QueryWrapper<User> queryWrapper = new QueryWrapper<>();
        Date updateTime = searchRequest.getUpdateTime();
        Date createTime = searchRequest.getCreateTime();
        // username
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.like("username", username);
        }
        // userAccount
        if (StringUtils.isNotBlank(userAccount)) {
            queryWrapper.like("userAccount", userAccount);
        }
        // gender
        if (StringUtils.isNotBlank(username)) {
            queryWrapper.eq("gender", gender);
        }
        // phone
        if (StringUtils.isNotBlank(phone)) {
            queryWrapper.like("phone", phone);
        }
        // email
        if (StringUtils.isNotBlank(email)) {
            queryWrapper.like("email", email);
        }
        // userStatus
        if (userStatus != null) {
            queryWrapper.eq("userStatus", userStatus);
        }

        if (StringUtils.isNotBlank(userRole)) {
            queryWrapper.eq("userRole", userRole);
        }

        if (StringUtils.isNotBlank(userCode)) {
            queryWrapper.eq("userCode", userCode);
        }

        if (updateTime != null) {
            queryWrapper.like("updateTime", updateTime);
        }
        if (createTime != null) {
            queryWrapper.like("createTime", createTime);
        }
        List<User> userList = userService.list(queryWrapper);
        List<User> users = userList.stream().map(userService::getSafteyUser).collect(Collectors.toList());
        return ResultUtils.success(users);
    }

```





